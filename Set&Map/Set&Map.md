# Set（ES6提供）

类似于数组，但是成员的值都是唯一的，没有重复值
Set本身是一个构造函数，用来生成Set数据结构

## 实例

### 属性

- constructor

  构造函数，默认是Set函数

- size

  返回Set实例的成员总数

### 方法

- 操作方法（操作数据）

	- add()

	  添加某一个值，返回Set结构本身

	- delete()

	  删除某个值，返回一个布尔值，表示删除是否成功

	- has()

	  返回一个布尔值，表示改制是否为Set的成员

	- clear()

	  清除所有成员，没有返回值

	- 其它

	  Array.from() 方法可以将Set 结构转为数组

- 遍历方法（遍历成员）

	- keys()

	  返回键名的遍历器

	- values()

	  返回键值的遍历器

	- entries()

	  返回键值对的遍历器

	- forEach()

	  使用回调函数遍历每个成员
	  没有返回值
	  第二个参数，表示绑定处理函数内部的this对象

	- 遍历的应用

	  扩展运算法（...） 内部使用for...of循环，所以可以用于Set结构
	  扩展运算符和Set结构相结合，就可以去除数组的重复成员

## WeakSet

结构与Set类似，也是不重复的值的集合。
区别1：WeakSet 的成员只能是对象，而不是其他类型的值
区别二：WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑WeakSet对改对象的引用，也就是说如果其他对象都不在引用该对象，那么垃圾回收机制会自动回收改对象所占用的内存，不考虑改对象还存在于WeakSet中（说明：垃圾回收机制依赖引用计数，如果一个值的引用次数不为0，垃圾回收机制就不会释放这块内存。结束使用该值之后有时会忘记取消引用，导致内存无法释放，进而可能会引发内存泄露。WeakSet里面的引用，都不计入垃圾回收机制，所以就存在这个问题。因此，WeakSet适合临时存放一组对象，以及存放跟对象绑定的消息。只要这些对象在外部消失，它在WeakSet里面的引用就会自动消失）
WeakSet因为上述特点，因此它的成员不适合引用的，因为他会随时消失。另外，由于WeakSet内部有多少个成员，取决于垃圾回收机制有没有运行，运行前后和可能成员个数是不一样的，而垃圾回收机制何时运行是不可预测的，因此WeakSet不可遍历

### 语法

- 可以使用new命令，创建WeakSet数据结构
- 接受一个数组或者类似数组的兑现作为参数（任何具有Iterator接口的对象，都可以作为WeakSet的参数）该数组的所有成员，都会自动成为WeakSet实例对象的成员

  说明：是数组的成员成为WeakSet的成员，不是数组本身，意味着数组的成员只能是对象

### 方法

- add()

  向WeakSet实例添加一个新成员

- delete()

  清除WeakSet 实例的指定成员

- has()

  返回一个布尔值，表示某个值是否在WeakSet之中

## Map

引申：JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。
类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当做键。也就是说Object 结构提供了“字符串一值”的对应，Map结构提供了“值-值”，是一种更完善的Hash 结构实现。适用于“键值对”结构。
任何具有Iterator接口、且每个成员都是一个双元素的数组的结构都可以当做Map构造函数的参数

### 特点

如果对同一键多次赋值，后面的值将覆盖前面的值
如果读取一个未知的键，则返回undefined
只有对同一个对象的引用，Map结构才将其视为同一个键
Map的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞(clash)的问题
Map的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map将其视为同一个键。举例：0和-0就是一个键，布尔值true 和字符串true则是两个不同的键。另外，undefined和null也是两个不同键。虽然NaN不严格等于自身，但是Map将其视为同一个键

### 属性

- size

  返回Map结构的成员总数

### 方法

- set()

  设置键名key对应的键值为value，然后返回整个Map 结构。如果key已经有值，则键值会被更新，否则就新生成该键
  返回的是当前的Map对象，因此可以采用链式写法

- get()

  get方法读取key对应的键值，如果找不到key，返回undefined

- has()

  has方法返回一个布尔值，表示某个键是否在当前Map对象之中

- delete()

  删除某个键，返回true.
  删除失败，返回false

- clear()

  清除所有成员，没有返回值

- 遍历方法

	- keys()

	  返回键名

	- values()

	  返回键值的遍历器

	- entries()

	  返回所有成员的遍历器

	- forEach()

	  遍历Map的所有成员
	  接收第二个参数，绑定回调函数的this

### 与其他数据结构的互相转换

- Map转为数组

  使用扩展运算符
  const myMap = new Map()
    .set(true, 7)
    .set({foo: 3}, ['abc']);
  [...myMap]
  // [ [ true, 7 ], [ { foo: 3 }, [ 'abc' ] ] ]

- 数组转为Map

  将数组传入Map构造函数，就可以转为Map
  new Map([
    [true, 7],
    [{foo: 3}, ['abc']]
  ])
  // Map {
  //   true => 7,
  //   Object {foo: 3} => ['abc']
  // }

- Map 转为对象

  如果所有的Map的键都是字符串，他可以无损地转为对象

- 对象转为Map

  通过Object.entries()
  let obj = {"a":1, "b":2};
  let map = new Map(Object.entries(obj));

- Map 转为JSON

  转换过程总区分两种情况
  Map的键名都是字符串，这时可以选择转为对象JSON
  Map 的键名有非字符串，这时可以选择转为数组JSON

- JSON转为Map

  JSON 转为Map，正常情况下，所有键名都是字符串
  如果整个JSON就是一个数组，且每个数组成员本身，有事一个有两个成员的数组，这时，他可以一一对应地转为Map

### WeakMap

结构与Map结构类似，也是用于生成键值对的集合

WeakMap与Map的区别
WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名
WeakMap 的键名所指向的对象，不计入垃圾回收机制
没有遍历操作
没有size属性

- get()
- set()
- has()
- delete()

*XMind: ZEN - Trial Version*